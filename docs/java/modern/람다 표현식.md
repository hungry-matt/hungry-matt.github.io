---
layout: default
title: 람다 표현식
parent: Modern
grand_parent: Java
---


Table of contents


- TOC
{:toc}


---

# 람다 표현식

## 람다란 무엇인가?

- 람다 표현식은 `이름이 없는 익명 함수`를 뜻한다.

- 람다는 메서드와 달리 클래스에 종속되지 않기 때문에 함수라 부른다.

- 함수라 불리지만 메서드 처럼 파라미터 리스트, 바디, 반환 형식을 가지며 예외를 던질 수 있다.

- 람다 표현식은 자바 8 부터 지원하며 익명 클래스 보다 더 간결하고 유연하게 구현할 수 있다.


### 익명 클래스

```java
Comparator<Apple> byWeight = new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWegiht());
    }
}
```

### 람다 표현식

```java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

- (Apple a1, Apple a2) : 람다 표현식의 파라미터 리스트에 해당하며 Comparator compare 메서드 파라미터 이다.

- a1.getWeight().compareTo(a2.getWeight()); : 람다의 바디에 해당하며 반환값에 해당하는 표현식 스타일이다.

- -> (화살표) : 파라미터 리스트와 바디를 구분한다.

### 자바 8에서 지원하는 다섯 가지 람다 표현식

Code | Description
---|---
(String s) -> s.length(); | String 형식의 파라미터 하나를 가지며 int를 반환한다. return이 함축되어 있으므로 명시하지 않아도 된다.
(Apple a) -> a.getWeight() > 150 | Apple 형식의 파라미터 하나를 가지며 boolean을 반환한다.
(int x, int y) -> { System.out.println("Result:"); System.out.println(x + y);} | int 형식의 파라미터를 두개 가지며 반환값이 없다.
() -> 42 | 파라미터가 없으며 int 42를 반환한다.
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); | Apple 형식의 파라미터를 두개 가지며 int를 반환한다.

### 람다 스타일

- 표현식 스타일

```java
(parameters) -> expression
```

- 블록 스타일

```java
(parameters) -> {statements;}
```

### 람다 예제

사용 사례 | 람다 예제
---|---
불리언 표현식 | (List<String> list) -> list.isEmpty()
객체 생성 | () -> new Apple(10)
객체에서 소비 | (Apple a) -> { System.out.println(a.getWeihgt()) }
객체에서 선택/추출 | (String s) -> s.length()
두 값을 조합 | (int a, int b) -> a * b;
두 객체 비교 | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())

## 어디에, 어떻게 람다를 사용할까?

- 람다 표현식은 함수형 인터페이스를 기대하는 곳에서만 사용할 수 있다.

### 함수형 인터페이스

- 함수형 인터페이스는 `단 하나의 추상 메서드만 가진다.`

- 람다 표현식은 함수형 인터페이스의 추상 메서드를 구현하여 전달 하기 때문에 `전체 표현식은 함수형 인터페이스의 인스턴스로 취급`한다.

- 다음은 자바 API의 함수형 인터페이스이다.

```java
// java.util.Comparator
public interface Comparator<T> {
    int compare(T o1, T o2);
}

// java.util.Runnable
public interface Runnalbe {
    void run();
}

// java.awt.event.ActionListener
// EventListener에는 추상 메서드가 없다.
public interface ActionListener extends EventListener {
    void actionPerfomed(ActionEvent e);
}

// java.util.concurrent.Callable
public interface Callable<V> {
    V call() throws Exception;
}

// java.security.PrivilegedAction
public interface PrivilegedAction<T> {
    T run();
}
```

### 함수 디스크립터

- 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가르키고 람다 표현식의 시그니처를 서술하는 메서드를 `함수 디스크립터`라 한다.

- 예를 들어 Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없는 시그니처로 생각할 수 있다.

- Runnable 인터페이스의 run 메서드 시그니처는 () -> void 표기하며 파라미터가 없고 void를 반환하는 함수를 의미한다.

- 한 가지 더 예를 들면 (Apple, Apple) -> int 표기는 두 개의 Apple을 파라미터로 받고 int를 반환하는 함수를 의미한다.