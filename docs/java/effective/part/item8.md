---
layout: default
title: item 8. finalizer와 cleaner 사용을 피하라
parent: Part1
grand_parent: Effective
---


Table of contents


- TOC
{:toc}


---

# finalizer와 cleaner 사용을 피하라

자바에서 제공하는 두 가지 객체 소멸자 `finalizer`와 `cleaner`는 나름의 쓰임새가 몇 가지 있긴 하지만 기본적으로 '쓰지 말아야' 한다.

## 쓰지 말아야 하는 이유

- finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- clenaer는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

### 즉시 수행된다는 보장이 없다.

finalizer나 cleaner가 실행되기까지 얼마나 걸릴지 알 수 없다. 즉, 제때 실행되어야 하는 작업은 절대 할 수 없으며 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸다. 이는 가비지 컬렉터 구현마다 천차만별이다.

### 인스턴의 자원 회수가 제멋대로 지연될 수 있다.

클래스에 finalizer를 달아두면 그 인스턴스의 자원 회수가 제멋대로 지연될 수 있다. 또한 finalizer 스레드는 다른 스레드보다 우선 순위가 낮아 실행될 기회를 얻지 못할 수 있다. clenaer는 자신을 수행할 스레드를 제어할 수 있지만, 여전히 가비지 컬렉터의 통제하에 있어 즉각 수행되리라는 보장이 없다.

### 수행 여부를 보장하지 않는다.

접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다. 따라서 `상태를 영구적으로 수정하는 작업에서는 절대로 finalizer나 cleaner에 의존해서는 안 된다.` 

예를 들어 데이터베이스 같은 공유 자원의 영구 락(lock) 해제를 finalizer나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출 것이다.

### 동작 중 발생한 예외가 무시된다.

finalizer 동작 중 예외가 무시되며, 처리할 작업이 남아 있더라도 그 순간 종료된다. 잡지 못한 예외 때문에 해당 객체는 마무리가 덜 된 상태로 남을 수 있다. 이처럼 다른 스레드가 훼손된 객체를 사용 한다면 어떻게 동작할지 예측할 수 없다.

그나마 cleaner는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하진 않는다.

### 심각한 성능 문제를 동반한다.

가비지 컬렉터의 효율을 떨어뜨린다.

### 심각한 보안 문제를 일으킬 수도 있다.

생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스 finalizer가 수행될 수 있게 된다. 있어서는 안 될 일이며 이 finalizer는 정적 필드에 자신의 참조를 할당하여 GC가 수집하지 못하게 막을 수 있다.

## finalizer와 cleaner를 사용하는 이유

자원의 소유자가 close 메서드를 호출하지 않는 것을 대비한 안정망 역할이다. cleaner나 finalizer가 즉시 호출되리라는 보장이 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 좋다.

가비지 컬렉터가 알지 못하는 네이티브 객체를 회수할 때 사용된다. 그렇기 때문에 cleaner나 finalizer가 처리하기 적당한 작업이다.



